{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/Ian/football-stats-app/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient }\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ||\r\n  new PrismaClient({\r\n    log: ['query'],\r\n  })\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,kBAAkB;AAEjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6HAAA,CAAA,eAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/Ian/football-stats-app/src/app/api/playerprofile/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport { prisma } from '@/lib/prisma';\r\n\r\n// Fetch player profile by ID\r\nexport async function GET(request: Request) {\r\n  try {\r\n    console.log(\"Fetching player profile...\");\r\n\r\n    // Extract player ID from query parameters\r\n    const { searchParams } = new URL(request.url);\r\n    const id = searchParams.get('id');\r\n\r\n    // Validate the ID\r\n    if (!id) {\r\n      console.error(\"Error: No ID provided in request\");\r\n      return NextResponse.json({ error: 'No ID provided' }, { status: 400 });\r\n    }\r\n\r\n    const numericId = parseInt(id, 10);\r\n    console.log('Fetching profile for ID:', numericId);\r\n\r\n    // Fetch player profile using a complex SQL query\r\n    const playerProfile = await prisma.$queryRaw`\r\n      WITH \r\n        player_stats AS (\r\n          SELECT \r\n            p.player_id,\r\n            p.name,\r\n            COUNT(pm.match_id) as games_played,\r\n            SUM(\r\n              CASE \r\n                WHEN pm.result = 'win' AND pm.heavy_win = true THEN 30\r\n                WHEN pm.result = 'win' THEN 20\r\n                WHEN pm.result = 'draw' THEN 10\r\n                WHEN pm.result = 'loss' AND pm.heavy_loss = true THEN -20\r\n                WHEN pm.result = 'loss' THEN -10\r\n                ELSE 0 END\r\n            ) as fantasy_points,\r\n            MAX(pm.goals) as most_goals,\r\n            (\r\n              SELECT m2.match_date::text\r\n              FROM player_matches pm2\r\n              JOIN matches m2 ON pm2.match_id = m2.match_id\r\n              WHERE pm2.player_id = p.player_id AND pm2.goals = (\r\n                SELECT MAX(pm3.goals)\r\n                FROM player_matches pm3\r\n                WHERE pm3.player_id = p.player_id\r\n              )\r\n              LIMIT 1\r\n            ) as most_goals_date\r\n          FROM players p\r\n          LEFT JOIN player_matches pm ON p.player_id = pm.player_id\r\n          WHERE p.player_id = ${numericId}\r\n          GROUP BY p.player_id, p.name\r\n        ),\r\n        streaks AS (\r\n          WITH numbered_matches AS (\r\n            SELECT \r\n              pm.player_id,\r\n              m.match_date,\r\n              pm.result,\r\n              ROW_NUMBER() OVER (PARTITION BY pm.player_id ORDER BY m.match_date) as match_num\r\n            FROM player_matches pm\r\n            JOIN matches m ON pm.match_id = m.match_id\r\n            WHERE pm.player_id = ${numericId}\r\n          ),\r\n          win_gaps AS (\r\n            SELECT \r\n              player_id,\r\n              match_date,\r\n              match_num,\r\n              match_num - ROW_NUMBER() OVER (ORDER BY match_date) as grp\r\n            FROM numbered_matches\r\n            WHERE result = 'win'\r\n          ),\r\n          undefeated_gaps AS (\r\n            SELECT \r\n              player_id,\r\n              match_date,\r\n              match_num,\r\n              match_num - ROW_NUMBER() OVER (ORDER BY match_date) as grp\r\n            FROM numbered_matches\r\n            WHERE result != 'loss'\r\n          ),\r\n          win_streak AS (\r\n            SELECT \r\n              player_id,\r\n              COUNT(*) as streak,\r\n              MIN(match_date) as start_date,\r\n              MAX(match_date) as end_date\r\n            FROM win_gaps\r\n            GROUP BY player_id, grp\r\n          ),\r\n          undefeated_streak AS (\r\n            SELECT \r\n              player_id,\r\n              COUNT(*) as streak,\r\n              MIN(match_date) as start_date,\r\n              MAX(match_date) as end_date\r\n            FROM undefeated_gaps\r\n            GROUP BY player_id, grp\r\n          )\r\n          SELECT \r\n            ws.player_id,\r\n            MAX(ws.streak) as win_streak,\r\n            MIN(ws.start_date)::text as win_streak_start,\r\n            MAX(ws.end_date)::text as win_streak_end,\r\n            MAX(us.streak) as undefeated_streak,\r\n            MIN(us.start_date)::text as undefeated_streak_start,\r\n            MAX(us.end_date)::text as undefeated_streak_end\r\n          FROM win_streak ws\r\n          CROSS JOIN undefeated_streak us\r\n          WHERE ws.player_id = us.player_id\r\n          GROUP BY ws.player_id\r\n        ),\r\n        yearly_stats AS (\r\n          SELECT \r\n            pm.player_id,\r\n            EXTRACT(YEAR FROM m.match_date)::integer as year,\r\n            COUNT(*) as games_played,\r\n            SUM(pm.goals) as goals_scored,\r\n            SUM(\r\n              CASE \r\n                WHEN pm.result = 'win' AND pm.heavy_win = true THEN 30\r\n                WHEN pm.result = 'win' THEN 20\r\n                WHEN pm.result = 'draw' THEN 10\r\n                WHEN pm.result = 'loss' AND pm.heavy_loss = true THEN -20\r\n                WHEN pm.result = 'loss' THEN -10\r\n                ELSE 0 END\r\n            ) as fantasy_points,\r\n            ROUND(COUNT(*) * 60.0 / NULLIF(SUM(pm.goals), 0), 1) as minutes_per_goal,\r\n            ROUND(SUM(\r\n              CASE \r\n                WHEN pm.result = 'win' AND pm.heavy_win = true THEN 30\r\n                WHEN pm.result = 'win' THEN 20\r\n                WHEN pm.result = 'draw' THEN 10\r\n                WHEN pm.result = 'loss' AND pm.heavy_loss = true THEN -20\r\n                WHEN pm.result = 'loss' THEN -10\r\n                ELSE 0 END\r\n            ) / COUNT(*), 1) as points_per_game\r\n          FROM player_matches pm\r\n          JOIN matches m ON pm.match_id = m.match_id\r\n          WHERE pm.player_id = ${numericId}\r\n          GROUP BY pm.player_id, EXTRACT(YEAR FROM m.match_date)\r\n          ORDER BY year DESC\r\n        )\r\n      SELECT \r\n        ps.*, \r\n        s.win_streak, \r\n        s.win_streak_start, \r\n        s.win_streak_end, \r\n        s.undefeated_streak, \r\n        s.undefeated_streak_start, \r\n        s.undefeated_streak_end,\r\n        (\r\n          SELECT json_agg(ys.*)\r\n          FROM yearly_stats ys\r\n        ) as yearly_stats\r\n      FROM player_stats ps\r\n      LEFT JOIN streaks s ON ps.player_id = s.player_id;\r\n    `;\r\n\r\n    // Handle case where player is not found\r\n    if (!playerProfile || playerProfile.length === 0) {\r\n      console.warn('Player not found for ID:', numericId);\r\n      return NextResponse.json({ error: 'Player not found' }, { status: 404 });\r\n    }\r\n\r\n    // Serialize the profile data (convert BigInt to numbers/strings)\r\n    const serializedProfile = {\r\n      ...playerProfile[0],\r\n      games_played: Number(playerProfile[0].games_played),\r\n      fantasy_points: Number(playerProfile[0].fantasy_points),\r\n      most_goals: Number(playerProfile[0].most_goals),\r\n      win_streak: Number(playerProfile[0].win_streak),\r\n      undefeated_streak: Number(playerProfile[0].undefeated_streak),\r\n      yearly_stats: playerProfile[0].yearly_stats?.map(stat => ({\r\n        year: Number(stat.year),\r\n        games_played: Number(stat.games_played),\r\n        goals_scored: Number(stat.goals_scored),\r\n        fantasy_points: Number(stat.fantasy_points),\r\n        minutes_per_goal: Number(stat.minutes_per_goal) || 'N/A',\r\n        points_per_game: Number(stat.points_per_game) || 'N/A',\r\n      })),\r\n      win_streak_dates: `${playerProfile[0].win_streak_start} to ${playerProfile[0].win_streak_end}`,\r\n      undefeated_streak_dates: `${playerProfile[0].undefeated_streak_start} to ${playerProfile[0].undefeated_streak_end}`\r\n    };\r\n\r\n    // Return the serialized profile\r\n    return NextResponse.json({ profile: serializedProfile });\r\n\r\n  } catch (error) {\r\n    console.error('Database Error:', error);\r\n    return NextResponse.json(\r\n      {\r\n        error: 'Failed to fetch player profile',\r\n        details: error instanceof Error ? error.message : 'Unknown error occurred',\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// Fetch all players for the dropdown (excluding ringers)\r\nexport async function GET_PLAYERS(request: Request) {\r\n  try {\r\n    console.log(\"Fetching all players...\");\r\n\r\n    // Fetch all players from the database, excluding ringers\r\n    const players = await prisma.$queryRaw`\r\n      SELECT DISTINCT \r\n        players.player_id as id,\r\n        players.name\r\n      FROM players\r\n      WHERE is_ringer = false\r\n      ORDER BY name ASC\r\n    `;\r\n\r\n    console.log('Players fetched:', players); // Debugging: Log the fetched players\r\n\r\n    // Return the players data under the \"data\" key\r\n    return NextResponse.json({ data: players });\r\n  } catch (error) {\r\n    console.error('Database Error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Failed to fetch players' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 314, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}