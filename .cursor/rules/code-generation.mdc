---
alwaysApply: true
---

# BerkoTNF Project Rules

## File Organization
- Organize code by feature, not by type
- Use App Router (Next.js 13+) - pages in `/app`, components in `/components`
- Backend assets: Supabase Edge Functions in `supabase/functions/`, SQL scripts in `sql/`

## Naming Conventions
- Components: `{ComponentName}.component.tsx`
- Pages: `{PageName}.page.tsx`  
- Layouts: `{LayoutName}.layout.tsx`
- Hooks: `use{HookName}.hook.ts`
- Utilities: `{utilName}.util.ts`
- Services: `{ServiceName}.service.ts`

## Import Conventions
- Use absolute imports with `@/` prefix
- Import UI components individually, avoid barrel exports
- Example: `import Button from '@/components/ui-kit/Button.component';`

## React Conventions
- Add `'use client'` directive for client-side components
- Use functional components with hooks
- Use TypeScript interfaces for props
- Prefer explicit prop types over `React.FC<Props>`

## Directory Structure
```
src/
‚îú‚îÄ‚îÄ app/                    # App Router pages and layouts
‚îú‚îÄ‚îÄ components/            # React components by feature
‚îÇ   ‚îú‚îÄ‚îÄ admin/             # Admin-related components
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/         # Dashboard widgets
‚îÇ   ‚îú‚îÄ‚îÄ layout/            # Layout components
‚îÇ   ‚îú‚îÄ‚îÄ navigation/        # Navigation components
‚îÇ   ‚îú‚îÄ‚îÄ ui-kit/            # Reusable UI components
‚îú‚îÄ‚îÄ contexts/              # React Context providers
‚îú‚îÄ‚îÄ hooks/                 # Custom React hooks
‚îú‚îÄ‚îÄ services/              # Business logic and API services
‚îú‚îÄ‚îÄ types/                 # TypeScript type definitions
‚îî‚îÄ‚îÄ utils/                 # Utility functions
```

## Database Access Patterns

### üö® CRITICAL: Multi-Tenancy Security (MANDATORY)

**RLS DOES NOT ENFORCE** - Explicit tenant filtering is your ONLY security.

**Every tenant-scoped query MUST include `where: { tenant_id }`**

### API Routes - Phase 2 Pattern (MANDATORY - October 2025)

**ALWAYS use `withTenantContext` wrapper** for all tenant-scoped API routes.

**‚úÖ CORRECT PATTERN (Phase 2):**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { withTenantContext } from '@/lib/tenantContext';
import { requireAdminRole } from '@/lib/auth/apiAuth';
import { prisma } from '@/lib/prisma';
import { handleTenantError } from '@/lib/api-helpers';

export async function GET(request: NextRequest) {
  return withTenantContext(request, async (tenantId) => {
    try {
      await requireAdminRole(request);  // Verify admin access
      
      const data = await prisma.players.findMany({
        where: { 
          tenant_id: tenantId  // ‚ö†Ô∏è MANDATORY - defense-in-depth
        }
      });
      
      return NextResponse.json({ success: true, data });
    } catch (error) {
      return handleTenantError(error);
    }
  });
}
```

**‚ùå DEPRECATED PATTERN - DO NOT USE:**
```typescript
// This pattern is from PRE-Phase 2 (missing RLS context)
export async function GET(request: NextRequest) {
  const { tenantId } = await requireAdminRole(request);  // ‚ùå Old pattern
  const data = await prisma.players.findMany({
    where: { tenant_id: tenantId }  // ‚úÖ Filtered but ‚ùå no RLS context
  });
  return NextResponse.json({ data });
}
```

**Why withTenantContext is required:**
- ‚úÖ Sets RLS context via AsyncLocalStorage (Prisma middleware can monitor)
- ‚úÖ Enables consistent logging: `[WITH_TENANT_CONTEXT] Setting tenant context`
- ‚úÖ Provides defense-in-depth (RLS + manual filtering)
- ‚úÖ Future-proof for strict RLS enforcement

**Edge Functions** - Use Supabase Client
- Supabase Edge Functions in `supabase/functions/` should use Supabase client
- SQL scripts in `sql/` use direct PostgreSQL

**Type Safety:**
- Use `as any` for Prisma selects with newer schema fields not yet in generated types
- Follow existing working API patterns (see `src/app/api/playerprofile/route.ts`)

## App Router Flow
- Pages in `/app` should be minimal - just import and render components
- Business logic and UI should live in `/components`
- Example pattern:
```typescript
// /app/some-route/page.tsx
import { SomeComponent } from '@/components/feature';
export default function SomePage() {
  return <SomeComponent />;
}
```

## Component Template
```typescript
'use client';
import React from 'react';

interface ComponentProps {
  children: React.ReactNode;
  // other props
}

const ComponentName = ({ children }: ComponentProps) => {
  return (
    // component JSX
  );
};

export default ComponentName;
```

## Key Feature Directories
- `/components/dashboard/` - Dashboard widgets (PersonalBests, Milestones, MatchReport)
- `/components/records/` - All-time records (LeaderboardStats, Legends, Feats)  
- `/components/tables/` - Season standings (CurrentHalfSeason, OverallSeasonPerformance)
- `/components/ui-kit/` - Reusable UI components

### Canonical Player Data Types

To ensure consistency and type safety, all player-related data across the application must conform to the canonical types defined in `src/types/player.types.ts`.

-   **Primary Type:** `PlayerProfile` is the base interface for any player.
-   **Contextual Types:** Use extended types like `PlayerInPool` or `PlayerWithStats` for specific use cases (e.g., match management, statistics).
-   **API Boundary:** The API layer is responsible for transforming raw database results (snake_case) into these camelCase canonical types using the helpers in `src/lib/transform/player.transform.ts`. Frontend components should expect to receive data in this clean format.
-   **Deprecation:** Avoid using or creating any local, one-off player types (e.g., `MatchPlayer`, `PlayerWithNameAndId`). Always import from the canonical types file.
-   **ID Convention:** The canonical frontend type `PlayerProfile` uses `id: string` for consistency with component keys and other browser APIs. The database uses `player_id: number`. The transformation helpers in `src/lib/transform/player.transform.ts` are responsible for converting the numeric ID from the database to a string. Conversely, API routes must parse string IDs from the frontend back into numbers before performing database operations.

---

# General Code Generation Rules

## SQL File Handling

### Schema Migrations
- **NEVER** create migration .sql files
- **ALWAYS** provide migration SQL in markdown blocks for manual execution in Supabase SQL editor
- **NEVER** use tools to execute exploratory SQL queries

### Business Logic SQL Functions
- **DO** create SQL function files in `/sql/` when implementing features that require complex database logic
- Use service prefix naming: `rsvp_*.sql`, `stats_*.sql`, etc.
- These are deployed via `deploy_all.ps1` script
- Examples: aggregation functions, state machines, complex filtering

### When to Use SQL Functions vs Application Code

**Use SQL functions in `/sql/` for:**
- Multi-table aggregations
- Performance-critical bulk operations  
- Complex business logic better expressed in SQL
- Logic that matches existing patterns (see `/sql/update_aggregated_*.sql`)

**Use application code for:**
- Simple CRUD operations
- Token generation/validation
- Rate limiting
- Session management
- API orchestration

## File Creation
- Only create new files when explicitly requested by the user.
- Prefer editing existing files over creating new ones.
- Clean up any temporary or test files created during development.

## Database Operations
- Provide all SQL queries as copyable code blocks.
- The user will execute the query and provide the results.
- Use the provided results for subsequent analysis and recommendations.
- **DO NOT** attempt to run database migrations (e.g., `prisma migrate`). The user will handle this.
