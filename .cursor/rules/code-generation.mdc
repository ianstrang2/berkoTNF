---
alwaysApply: true
---

# Capo Project Rules

## File Organization
- Organize code by feature, not by type
- Use App Router (Next.js 13+) - pages in `/app`, components in `/components`
- Backend assets: Supabase Edge Functions in `supabase/functions/`, SQL scripts in `sql/`

## Naming Conventions
- Components: `{ComponentName}.component.tsx`
- Pages: `{PageName}.page.tsx`  
- Layouts: `{LayoutName}.layout.tsx`
- Hooks: `use{HookName}.hook.ts`
- Utilities: `{utilName}.util.ts`
- Services: `{ServiceName}.service.ts`

## Import Conventions
- Use absolute imports with `@/` prefix
- Import UI components individually, avoid barrel exports
- Example: `import Button from '@/components/ui-kit/Button.component';`

## React Conventions
- Add `'use client'` directive for client-side components
- Use functional components with hooks
- Use TypeScript interfaces for props
- Prefer explicit prop types over `React.FC<Props>`

## Directory Structure
```
src/
‚îú‚îÄ‚îÄ app/                    # App Router pages and layouts
‚îú‚îÄ‚îÄ components/            # React components by feature
‚îÇ   ‚îú‚îÄ‚îÄ admin/             # Admin-related components
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/         # Dashboard widgets
‚îÇ   ‚îú‚îÄ‚îÄ layout/            # Layout components
‚îÇ   ‚îú‚îÄ‚îÄ navigation/        # Navigation components
‚îÇ   ‚îú‚îÄ‚îÄ ui-kit/            # Reusable UI components
‚îú‚îÄ‚îÄ contexts/              # React Context providers
‚îú‚îÄ‚îÄ hooks/                 # Custom React hooks
‚îú‚îÄ‚îÄ services/              # Business logic and API services
‚îú‚îÄ‚îÄ types/                 # TypeScript type definitions
‚îî‚îÄ‚îÄ utils/                 # Utility functions
```

## Database Access Patterns

### üö® CRITICAL: Multi-Tenancy Security (MANDATORY)

**RLS DOES NOT ENFORCE** - Explicit tenant filtering is your ONLY security.

**Every tenant-scoped query MUST include `where: { tenant_id }`**

### API Routes - Phase 2 Pattern (MANDATORY - October 2025)

**ALWAYS use `withTenantContext` wrapper + `withTenantFilter()` helper** for all tenant-scoped API routes.

**‚úÖ CORRECT PATTERN (Phase 2):**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { withTenantContext } from '@/lib/tenantContext';
import { withTenantFilter } from '@/lib/tenantFilter';
import { requireAdminRole } from '@/lib/auth/apiAuth';
import { prisma } from '@/lib/prisma';
import { handleTenantError } from '@/lib/api-helpers';

export async function GET(request: NextRequest) {
  return withTenantContext(request, async (tenantId) => {
    try {
      await requireAdminRole(request);  // Verify admin access
      
      const data = await prisma.players.findMany({
        where: withTenantFilter(tenantId)  // ‚ö†Ô∏è MANDATORY - type-safe tenant isolation
      });
      
      return NextResponse.json({ success: true, data });
    } catch (error) {
      return handleTenantError(error);
    }
  });
}
```

**‚ùå DEPRECATED PATTERN - DO NOT USE:**
```typescript
// This pattern is from PRE-Phase 2 (missing tenant context wrapper)
export async function GET(request: NextRequest) {
  const { tenantId } = await requireAdminRole(request);  // ‚ùå Old pattern
  const data = await prisma.players.findMany({
    where: { tenant_id: tenantId }  // ‚ùå Manual filtering
  });
  return NextResponse.json({ data });
}
```

**Why withTenantContext + withTenantFilter are required:**
- ‚úÖ Sets tenant context via AsyncLocalStorage (enables consistent logging)
- ‚úÖ Type-safe tenant filtering (impossible to forget tenant_id)
- ‚úÖ Consistent error handling via `handleTenantError()`
- ‚úÖ Defense-in-depth security model

**NOTE:** Some older routes may use inline error handling instead of `handleTenantError()`. 
When editing these routes, migrate to `handleTenantError()` for consistency.

**Authentication Helpers:**
- `requireAdminRole(request)` - Admin/superadmin access (returns `{ user, userRole, tenantId, linkedPlayerId }`)
- `requirePlayerAccess(request)` - Player access (returns `{ user, player, tenantId }`)
- For public routes: Use `withTenantContext(request, handler, { allowUnauthenticated: true })`

**Edge Functions** - Use Supabase Client
- Supabase Edge Functions in `supabase/functions/` should use Supabase client
- SQL scripts in `sql/` use direct PostgreSQL

**Type Safety:**
- Use `as any` for Prisma selects with newer schema fields not yet in generated types
- Follow existing working API patterns (see `src/app/api/playerprofile/route.ts`)

## React Query - Multi-Tenant Cache Isolation (MANDATORY)

### üö® CRITICAL: All Query Keys MUST Include tenant_id

**React Query caches data globally** - without tenant_id in keys, Tenant A's data can be served to Tenant B!

**‚úÖ CORRECT PATTERN:**
```typescript
import { useAuth } from '@/hooks/useAuth.hook';
import { queryKeys } from '@/lib/queryKeys';

async function fetchPlayers(tenantId: string | null): Promise<PlayerProfile[]> {
  // Gracefully handle missing tenantId - return empty data
  if (!tenantId) return [];
  
  const response = await fetch('/api/players', { credentials: 'include' });
  if (!response.ok) throw new Error(`API returned ${response.status}`);
  const result = await response.json();
  return result.data || [];
}

export function usePlayers() {
  const { profile } = useAuth();
  const tenantId = profile.tenantId;
  
  return useQuery({
    queryKey: queryKeys.players(tenantId),  // ‚úÖ Includes tenant_id
    queryFn: () => fetchPlayers(tenantId),  // ‚úÖ Pass tenantId to fetch
    staleTime: 10 * 60 * 1000,
    // ‚úÖ NO enabled condition - queryFn handles missing tenantId gracefully
  });
}
```

**‚ùå BROKEN PATTERNS - CAUSES DATA LEAKS:**
```typescript
// Pattern 1: No tenant_id in query key
export function usePlayers() {
  return useQuery({
    queryKey: queryKeys.players(),  // ‚ùå No tenant_id - cache shared across ALL tenants!
    queryFn: fetchPlayers,
  });
}

// Pattern 2: Using enabled condition (causes race condition)
export function usePlayers() {
  const { profile } = useAuth();
  return useQuery({
    queryKey: queryKeys.players(profile.tenantId),
    queryFn: fetchPlayers,
    enabled: !!profile.tenantId,  // ‚ùå Query stays disabled if checked before auth loads!
  });
}
```

**Why this matters:**
- ‚úÖ Isolates cached data per tenant
- ‚úÖ Prevents showing Tenant A's data to Tenant B
- ‚úÖ Fixes "No Data Available" issues during tenant switching
- ‚úÖ Prevents race conditions (query always runs when tenantId becomes available)
- ‚úÖ Security: Prevents cross-tenant data leaks in browser cache

**Key Points:**
1. **Include `tenantId` in query key** - Isolates cache per tenant
2. **Pass `tenantId` to fetchFn** - Allows graceful handling of missing auth
3. **NO `enabled` condition** - Avoids permanent disable race condition
4. **Early return in fetchFn** - Returns empty data if `tenantId` is null

**Exception:** `authProfile()` query key does NOT need tenant_id (auth is global)

## API Response Headers - HTTP Cache (MANDATORY)

### üö® CRITICAL: Disable HTTP Caching for Tenant-Scoped Data

**NEVER use HTTP caching for tenant-scoped data** - browser cache persists stale data across page reloads and tenant switches!

**‚úÖ CORRECT PATTERN (All tenant-scoped APIs):**
```typescript
export async function GET(request: NextRequest) {
  return withTenantContext(request, async (tenantId) => {
    const data = await prisma.players.findMany({
      where: { tenant_id: tenantId }
    });
    
    return NextResponse.json({ data }, {
      headers: {
        'Cache-Control': 'no-store, must-revalidate',  // ‚úÖ No HTTP cache
        'Pragma': 'no-cache',  // ‚úÖ Legacy browser support
        'Vary': 'Cookie',  // ‚úÖ Tenant context varies by cookie
      }
    });
  });
}
```

**‚ùå BROKEN PATTERN - CAUSES STALE DATA:**
```typescript
export async function GET(request: NextRequest) {
  return withTenantContext(request, async (tenantId) => {
    const data = await prisma.players.findMany({
      where: { tenant_id: tenantId }
    });
    
    return NextResponse.json({ data }, {
      headers: {
        'Cache-Control': 'private, max-age=300',  // ‚ùå Browser caches for 5 min!
        'Vary': 'Cookie',
      }
    });
  });
}
```

**Why this matters:**
- ‚ùå HTTP cache persists across page reloads (stale data bug)
- ‚ùå Tenant A's cached data can appear briefly for Tenant B
- ‚ùå Database changes don't reflect until cache expires (5 min lag)
- ‚úÖ React Query handles caching correctly (in-memory, tenant-aware)
- ‚úÖ Disabling HTTP cache doesn't hurt performance (React Query deduplicates)

**Exception:** Auth profile can use short cache (1 min max)

## Multi-Tenant Security: RLS Strategy (MANDATORY - October 2025)

### üö® CRITICAL: RLS Architecture Decision

**Background:** Row-Level Security (RLS) + connection pooling causes intermittent 0-row query results. 
When middleware sets RLS context on Connection A, but query executes on Connection B without context, 
queries return 0 rows even with explicit `WHERE tenant_id = ...` filters.

**Solution:** Disable RLS on operational tables, enforce security via application-level `withTenantFilter()` helper.

### Database Security Model

**Tables with RLS ENABLED (Auth & Security Critical):**
- `auth.*` - Supabase auth system tables
- `tenants` - Superadmin-only access, requires RLS
- `admin_profiles` - Role/permission data, requires RLS

**Tables with RLS DISABLED (Operational - Use `withTenantFilter()`):**
- **Aggregated tables:** All tables starting with `aggregated_*` (read-only, populated by background jobs)
- **Core entities:** `players`, `matches`, `player_matches`, `seasons`
- **Match management:** `upcoming_matches`, `upcoming_match_players`, `match_player_pool`, `team_slots`
- **Configuration:** `app_config`, `balance_config`, `team_templates`
- **Player onboarding:** `player_join_requests`

### MANDATORY: Use `withTenantFilter()` Helper

**ALL queries to tables with RLS disabled MUST use `withTenantFilter()` helper:**

**‚úÖ CORRECT PATTERN:**
```typescript
import { withTenantFilter } from '@/lib/tenantFilter';

// Simple query
const players = await prisma.players.findMany({
  where: withTenantFilter(tenantId)
});

// With additional filters
const activePlayers = await prisma.players.findMany({
  where: withTenantFilter(tenantId, {
    is_retired: false,
    is_active: true
  })
});

// With complex filters (OR/AND)
const matches = await prisma.matches.findMany({
  where: withTenantFilter(tenantId, {
    OR: [
      { upcoming_match_id: null },
      { upcoming_matches: { state: 'Completed' } }
    ]
  })
});

// With composite keys (findUnique)
const stats = await prisma.aggregated_player_profile_stats.findUnique({
  where: { 
    ...withTenantFilter(tenantId), 
    player_id: playerId 
  }
});
```

**‚ùå FORBIDDEN PATTERNS:**
```typescript
// Pattern 1: Missing tenant filter - SECURITY RISK!
const players = await prisma.players.findMany({
  where: { is_retired: false }  // ‚ùå No tenant_id! DATA LEAK!
});

// Pattern 2: Manual tenant_id - Less safe, no type checking
const players = await prisma.players.findMany({
  where: { 
    tenant_id: tenantId,  // ‚ùå Use withTenantFilter() instead
    is_retired: false 
  }
});

// Pattern 3: Spreading tenant_id manually
const players = await prisma.players.findMany({
  where: { 
    ...{ tenant_id: tenantId },  // ‚ùå Use withTenantFilter() instead
    is_retired: false 
  }
});
```

**Why `withTenantFilter()` is mandatory:**
- ‚úÖ Type-safe (throws error if tenantId is null/undefined)
- ‚úÖ Compile-time enforcement (impossible to forget tenant filtering)
- ‚úÖ Consistent pattern across entire codebase
- ‚úÖ Development logging helps debugging
- ‚úÖ Single source of truth for tenant filtering logic

### Special Cases

**Raw SQL Queries:**
When using `prisma.$queryRaw`, always include explicit tenant filtering:
```typescript
const seasons = await prisma.$queryRaw`
  SELECT * FROM seasons
  WHERE tenant_id = ${tenantId}::uuid
  ORDER BY start_date DESC
`;
```

**Nested Relations:**
Apply `withTenantFilter()` to all nested `where` clauses:
```typescript
const match = await prisma.upcoming_matches.findFirst({
  where: withTenantFilter(tenantId, { is_active: true }),
  include: {
    upcoming_match_players: {
      where: withTenantFilter(tenantId),  // ‚úÖ Filter nested relation
      include: { players: true }
    }
  }
});
```

### Migration Guide: Converting Manual Filters

**Before (Manual filtering):**
```typescript
const data = await prisma.players.findMany({
  where: { tenant_id: tenantId, is_retired: false }
});
```

**After (Using withTenantFilter):**
```typescript
const data = await prisma.players.findMany({
  where: withTenantFilter(tenantId, { is_retired: false })
});
```

**Remaining Work:** 51 instances of manual `tenant_id: tenantId` filtering exist across 29 files. 
Gradually migrate these to use `withTenantFilter()` as files are edited for other reasons.

## App Router Flow
- Pages in `/app` should be minimal - just import and render components
- Business logic and UI should live in `/components`
- Example pattern:
```typescript
// /app/some-route/page.tsx
import { SomeComponent } from '@/components/feature';
export default function SomePage() {
  return <SomeComponent />;
}
```

## Component Template
```typescript
'use client';
import React from 'react';

interface ComponentProps {
  children: React.ReactNode;
  // other props
}

const ComponentName = ({ children }: ComponentProps) => {
  return (
    // component JSX
  );
};

export default ComponentName;
```

## Key Feature Directories
- `/components/dashboard/` - Dashboard widgets (PersonalBests, Milestones, MatchReport)
- `/components/records/` - All-time records (LeaderboardStats, Legends, Feats)  
- `/components/tables/` - Season standings (CurrentHalfSeason, OverallSeasonPerformance)
- `/components/ui-kit/` - Reusable UI components

### Canonical Player Data Types

To ensure consistency and type safety, all player-related data across the application must conform to the canonical types defined in `src/types/player.types.ts`.

-   **Primary Type:** `PlayerProfile` is the base interface for any player.
-   **Contextual Types:** Use extended types like `PlayerInPool` or `PlayerWithStats` for specific use cases (e.g., match management, statistics).
-   **API Boundary:** The API layer is responsible for transforming raw database results (snake_case) into these camelCase canonical types using the helpers in `src/lib/transform/player.transform.ts`. Frontend components should expect to receive data in this clean format.
-   **Deprecation:** Avoid using or creating any local, one-off player types (e.g., `MatchPlayer`, `PlayerWithNameAndId`). Always import from the canonical types file.
-   **ID Convention:** The canonical frontend type `PlayerProfile` uses `id: string` for consistency with component keys and other browser APIs. The database uses `player_id: number`. The transformation helpers in `src/lib/transform/player.transform.ts` are responsible for converting the numeric ID from the database to a string. Conversely, API routes must parse string IDs from the frontend back into numbers before performing database operations.

---

# General Code Generation Rules

## SQL File Handling

### Schema Migrations
- **NEVER** create migration .sql files
- **ALWAYS** provide migration SQL in markdown blocks for manual execution in Supabase SQL editor
- **NEVER** use tools to execute exploratory SQL queries

### Business Logic SQL Functions
- **DO** create SQL function files in `/sql/` when implementing features that require complex database logic
- Use service prefix naming: `rsvp_*.sql`, `stats_*.sql`, etc.
- These are deployed via `deploy_all.ps1` script
- Examples: aggregation functions, state machines, complex filtering

### When to Use SQL Functions vs Application Code

**Use SQL functions in `/sql/` for:**
- Multi-table aggregations
- Performance-critical bulk operations  
- Complex business logic better expressed in SQL
- Logic that matches existing patterns (see `/sql/update_aggregated_*.sql`)

**Use application code for:**
- Simple CRUD operations
- Token generation/validation
- Rate limiting
- Session management
- API orchestration

## File Creation
- Only create new files when explicitly requested by the user.
- Prefer editing existing files over creating new ones.
- Clean up any temporary or test files created during development.

## Database Operations
- Provide all SQL queries as copyable code blocks.
- The user will execute the query and provide the results.
- Use the provided results for subsequent analysis and recommendations.
- **DO NOT** attempt to run database migrations (e.g., `prisma migrate`). The user will handle this.
