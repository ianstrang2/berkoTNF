---
alwaysApply: true
---

# Capo Project Rules

## File Organization
- Organize code by feature, not by type
- Use App Router (Next.js 13+) - pages in `/app`, components in `/components`
- Backend assets: Supabase Edge Functions in `supabase/functions/`, SQL scripts in `sql/`

## Naming Conventions
- Components: `{ComponentName}.component.tsx`
- Pages: `{PageName}.page.tsx`  
- Layouts: `{LayoutName}.layout.tsx`
- Hooks: `use{HookName}.hook.ts`
- Utilities: `{utilName}.util.ts`
- Services: `{ServiceName}.service.ts`

## Import Conventions
- Use absolute imports with `@/` prefix
- Import UI components individually, avoid barrel exports
- Example: `import Button from '@/components/ui-kit/Button.component';`

## React Conventions
- Add `'use client'` directive for client-side components
- Use functional components with hooks
- Use TypeScript interfaces for props
- Prefer explicit prop types over `React.FC<Props>`

## Directory Structure
```
src/
‚îú‚îÄ‚îÄ app/                    # App Router pages and layouts
‚îú‚îÄ‚îÄ components/            # React components by feature
‚îÇ   ‚îú‚îÄ‚îÄ admin/             # Admin-related components
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/         # Dashboard widgets
‚îÇ   ‚îú‚îÄ‚îÄ layout/            # Layout components
‚îÇ   ‚îú‚îÄ‚îÄ navigation/        # Navigation components
‚îÇ   ‚îú‚îÄ‚îÄ ui-kit/            # Reusable UI components
‚îú‚îÄ‚îÄ contexts/              # React Context providers
‚îú‚îÄ‚îÄ hooks/                 # Custom React hooks
‚îú‚îÄ‚îÄ services/              # Business logic and API services
‚îú‚îÄ‚îÄ types/                 # TypeScript type definitions
‚îî‚îÄ‚îÄ utils/                 # Utility functions
```

## Database Access Patterns

### üö® CRITICAL: Multi-Tenancy Security (MANDATORY)

**RLS DOES NOT ENFORCE** - Explicit tenant filtering is your ONLY security.

**Every tenant-scoped query MUST include `where: { tenant_id }`**

### API Routes - Phase 2 Pattern (MANDATORY)

**ALWAYS use `withTenantContext` wrapper + `withTenantFilter()` helper** for all tenant-scoped API routes.

### üö® CRITICAL: Authorization is MANDATORY for Admin/Superadmin Routes

**ALL routes under `/api/admin/*` MUST call `requireAdminRole()`**  
**ALL routes under `/api/superadmin/*` MUST call `requireSuperadmin()`**

**Why:** UI protection is NOT enough - users can call APIs directly via tools like Postman, curl, or browser DevTools.

**Admin Route Pattern:**
```typescript
import { requireAdminRole } from '@/lib/auth/apiAuth';

export async function GET(request: NextRequest) {
  return withTenantContext(request, async (tenantId) => {
    // üîí MANDATORY: Check authorization FIRST
    await requireAdminRole(request);
    
    // Now safe to proceed with admin operations
    const data = await prisma.players.findMany({
      where: withTenantFilter(tenantId)
    });
    return NextResponse.json({ success: true, data });
  });
}
```

**Superadmin Route Pattern:**
```typescript
import { requireSuperadmin } from '@/lib/auth/apiAuth';

export async function GET(request: NextRequest) {
  try {
    // üîí MANDATORY: Check superadmin authorization FIRST
    await requireSuperadmin(request);
    
    // Now safe to access cross-tenant data
    const tenants = await supabaseAdmin.from('tenants').select('*');
    return NextResponse.json({ success: true, data: tenants });
  } catch (error) {
    return handleTenantError(error);
  }
}
```

**Authentication Helpers:**
- `requireAdminRole(request)` - Verifies admin OR superadmin access (use for `/api/admin/*`)
- `requireSuperadmin(request)` - Verifies ONLY superadmin access (use for `/api/superadmin/*`)
- `requirePlayerAccess(request)` - Verifies player access (use for `/api/player/*`)
- `requireAuth(request)` - Verifies authentication only (rarely needed)

**For public routes:** Use `withTenantContext(request, handler, { allowUnauthenticated: true })`

**‚ùå NEVER:**
- Rely on UI checks alone (users can bypass UI)
- Check `referer` header for authorization (easily spoofed)
- Assume middleware handles authorization (it only checks authentication)
- Skip auth checks because "it's an internal API" (still exploitable)

## React Query - Multi-Tenant Cache Isolation (MANDATORY)

### üö® CRITICAL: All Query Keys MUST Include tenant_id

**React Query caches data globally** - without tenant_id in keys, Tenant A's data can be served to Tenant B!

**Pattern:**
```typescript
export function usePlayers() {
  const { profile } = useAuth();
  return useQuery({
    queryKey: queryKeys.players(profile.tenantId),  // ‚úÖ MUST include tenantId
    queryFn: () => fetchPlayers(profile.tenantId),
    // NO enabled condition - causes race conditions
  });
}
```

**Key Rules:**
1. Include `tenantId` in query key (isolates cache per tenant)
2. Pass `tenantId` to fetchFn (graceful handling if null)
3. NO `enabled` condition (avoids permanent disable race)
4. Early return empty data if tenantId is null

**Exception:** `authProfile()` key does NOT need tenant_id (auth is global)

## API Response Headers - HTTP Cache (MANDATORY)

### üö® CRITICAL: Disable HTTP Caching for Tenant-Scoped Data

**NEVER use HTTP caching for tenant-scoped data** - browser cache persists stale data across tenant switches!

**Required Headers:**
```typescript
      headers: {
  'Cache-Control': 'no-store, must-revalidate',
  'Pragma': 'no-cache',
  'Vary': 'Cookie',
}
```

**Why:** HTTP cache persists across reloads, React Query handles in-memory caching correctly.  
**Exception:** Auth profile can use 1 min cache max.

## Multi-Tenant Security: RLS Strategy (MANDATORY - October 2025)

### üö® CRITICAL: RLS Architecture Decision

**Background:** Row-Level Security (RLS) + connection pooling causes intermittent 0-row query results. 
When middleware sets RLS context on Connection A, but query executes on Connection B without context, 
queries return 0 rows even with explicit `WHERE tenant_id = ...` filters.

**Solution:** Disable RLS on operational tables, enforce security via application-level `withTenantFilter()` helper.

### Database Security Model

**Tables with RLS ENABLED (Auth & Security Critical):**
- `auth.*` - Supabase auth system tables
- `tenants` - Superadmin-only access, requires RLS
- `admin_profiles` - Role/permission data, requires RLS

**Tables with RLS DISABLED (Operational - Use `withTenantFilter()`):**
- **Aggregated tables:** All tables starting with `aggregated_*` (read-only, populated by background jobs)
- **Core entities:** `players`, `matches`, `player_matches`, `seasons`
- **Match management:** `upcoming_matches`, `upcoming_match_players`, `match_player_pool`, `team_slots`
- **Configuration:** `app_config`, `balance_config`, `team_templates`
- **Player onboarding:** `player_join_requests`

### MANDATORY: Use `withTenantFilter()` Helper

**ALL queries MUST use `withTenantFilter()` for tenant isolation:**

```typescript
import { withTenantFilter } from '@/lib/tenantFilter';

// Simple: withTenantFilter(tenantId)
// With filters: withTenantFilter(tenantId, { is_retired: false })
// With OR/AND: withTenantFilter(tenantId, { OR: [...] })
// With composite keys: { ...withTenantFilter(tenantId), player_id }
```

**‚ùå NEVER use manual `tenant_id: tenantId` filtering** - use helper for type safety.

**Special cases:** Raw SQL and nested relations - see `docs/SPEC_multi_tenancy.md`

## App Router Flow
- Pages in `/app` should be minimal - just import and render components
- Business logic and UI should live in `/components`
- Example pattern:
```typescript
// /app/some-route/page.tsx
import { SomeComponent } from '@/components/feature';
export default function SomePage() {
  return <SomeComponent />;
}
```

## Component Template
```typescript
'use client';
import React from 'react';

interface ComponentProps {
  children: React.ReactNode;
  // other props
}

const ComponentName = ({ children }: ComponentProps) => {
  return (
    // component JSX
  );
};

export default ComponentName;
```

## Key Feature Directories
- `/components/dashboard/` - Dashboard widgets (PersonalBests, Milestones, MatchReport)
- `/components/records/` - All-time records (LeaderboardStats, Legends, Feats)  
- `/components/tables/` - Season standings (CurrentHalfSeason, OverallSeasonPerformance)
- `/components/ui-kit/` - Reusable UI components

### Canonical Player Data Types

To ensure consistency and type safety, all player-related data across the application must conform to the canonical types defined in `src/types/player.types.ts`.

-   **Primary Type:** `PlayerProfile` is the base interface for any player.
-   **Contextual Types:** Use extended types like `PlayerInPool` or `PlayerWithStats` for specific use cases (e.g., match management, statistics).
-   **API Boundary:** The API layer is responsible for transforming raw database results (snake_case) into these camelCase canonical types using the helpers in `src/lib/transform/player.transform.ts`. Frontend components should expect to receive data in this clean format.
-   **Deprecation:** Avoid using or creating any local, one-off player types (e.g., `MatchPlayer`, `PlayerWithNameAndId`). Always import from the canonical types file.
-   **ID Convention:** The canonical frontend type `PlayerProfile` uses `id: string` for consistency with component keys and other browser APIs. The database uses `player_id: number`. The transformation helpers in `src/lib/transform/player.transform.ts` are responsible for converting the numeric ID from the database to a string. Conversely, API routes must parse string IDs from the frontend back into numbers before performing database operations.

---

## Marketing Pages - Analytics & Attribution

**ONLY track marketing pages** (`/`, `/pricing`), **NOT authenticated app** (`/admin/*`, `/player/*`).

- Use `<PlausibleScript />` on marketing pages (auto-detects pathname)
- Use `useAttribution()` hook to capture first-touch attribution
- Attribution stored in `tenants.settings` JSON field on signup

See `docs/SPEC_Marketing.md` for implementation details (if needed).

---

# General Code Generation Rules

## SQL File Handling

### Schema Migrations
- **NEVER** create migration .sql files
- **ALWAYS** provide migration SQL in markdown blocks for manual execution in Supabase SQL editor
- **NEVER** use tools to execute exploratory SQL queries

### Business Logic SQL Functions
- **DO** create SQL function files in `/sql/` when implementing features that require complex database logic
- Use service prefix naming: `rsvp_*.sql`, `stats_*.sql`, etc.
- These are deployed via `deploy_all.ps1` script
- Examples: aggregation functions, state machines, complex filtering

### When to Use SQL Functions vs Application Code

**Use SQL functions in `/sql/` for:**
- Multi-table aggregations
- Performance-critical bulk operations  
- Complex business logic better expressed in SQL
- Logic that matches existing patterns (see `/sql/update_aggregated_*.sql`)

**Use application code for:**
- Simple CRUD operations
- Token generation/validation
- Rate limiting
- Session management
- API orchestration

## Modal & Dialog Standards

**MANDATORY:** All modals must follow standardized patterns for consistency. See `docs/SPEC_Modals.md` for complete specification.

### When to Use Which Pattern

**Simple Confirmations (90% of cases):**
- Use: `SoftUIConfirmationModal` (SweetAlert2 wrapper)
- For: Delete confirmations, save confirmations, logout, alerts, success messages
- Never use: Legacy ConfirmationDialog, ConfirmationModal, ConfirmDialog (deleted)

**Complex Forms:**
- Use: Mobile-safe custom modal pattern (see template in SPEC_Modals.md Template B)
- For: Add/edit forms, multi-step flows, custom layouts
- Must: Test with mobile keyboard

### Design Standards (MANDATORY)

**Icons:** SVG only (no emojis in UI), gradient backgrounds (see SPEC_Modals.md)  
**Buttons:** Context-dependent order - safe action on LEFT for destructive (see spec)  
**Mobile:** Form modals MUST use keyboard-safe pattern (see SPEC_Modals.md Template B)  
**Z-Index:** All modals use `z-50` (standard)

### Modal Creation Checklist

When creating a new modal:
1. [ ] Choose pattern: SoftUIConfirmationModal OR custom form
2. [ ] Use SVG icons (never emojis)
3. [ ] Apply gradient button styling
4. [ ] Use context-appropriate button order (constructive vs destructive)
5. [ ] Test on mobile (with keyboard if has inputs)
6. [ ] Add `role="dialog"` + `aria-modal="true"`
7. [ ] Add entry to `docs/SPEC_Modals.md` inventory table

## File Creation
- Only create new files when explicitly requested by the user.
- Prefer editing existing files over creating new ones.
- Clean up any temporary or test files created during development.

## Database Operations
- Provide all SQL queries as copyable code blocks.
- The user will execute the query and provide the results.
- Use the provided results for subsequent analysis and recommendations.
- **DO NOT** attempt to run database migrations (e.g., `prisma migrate`). The user will handle this.
