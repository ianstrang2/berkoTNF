---
alwaysApply: true
---

# Capo Project Rules

## File Organization
- Organize code by feature, not by type
- Use App Router (Next.js 13+) - pages in `/app`, components in `/components`
- Backend assets: Supabase Edge Functions in `supabase/functions/`, SQL scripts in `sql/`

## Naming Conventions
- Components: `{ComponentName}.component.tsx`
- Pages: `{PageName}.page.tsx`  
- Layouts: `{LayoutName}.layout.tsx`
- Hooks: `use{HookName}.hook.ts`
- Utilities: `{utilName}.util.ts`
- Services: `{ServiceName}.service.ts`

## Import Conventions
- Use absolute imports with `@/` prefix
- Import UI components individually, avoid barrel exports
- Example: `import Button from '@/components/ui-kit/Button.component';`

## React Conventions
- Add `'use client'` directive for client-side components
- Use functional components with hooks
- Use TypeScript interfaces for props
- Prefer explicit prop types over `React.FC<Props>`

## Directory Structure
```
src/
‚îú‚îÄ‚îÄ app/                    # App Router pages and layouts
‚îú‚îÄ‚îÄ components/            # React components by feature
‚îÇ   ‚îú‚îÄ‚îÄ admin/             # Admin-related components
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/         # Dashboard widgets
‚îÇ   ‚îú‚îÄ‚îÄ layout/            # Layout components
‚îÇ   ‚îú‚îÄ‚îÄ navigation/        # Navigation components
‚îÇ   ‚îú‚îÄ‚îÄ ui-kit/            # Reusable UI components
‚îú‚îÄ‚îÄ contexts/              # React Context providers
‚îú‚îÄ‚îÄ hooks/                 # Custom React hooks
‚îú‚îÄ‚îÄ services/              # Business logic and API services
‚îú‚îÄ‚îÄ types/                 # TypeScript type definitions
‚îî‚îÄ‚îÄ utils/                 # Utility functions
```

## Database Access Patterns

### üö® CRITICAL: Multi-Tenancy Security (MANDATORY)

**RLS DOES NOT ENFORCE** - Explicit tenant filtering is your ONLY security.

**Every tenant-scoped query MUST include `where: { tenant_id }`**

### API Routes - Phase 2 Pattern (MANDATORY)

**ALWAYS use `withTenantContext` wrapper + `withTenantFilter()` helper** for all tenant-scoped API routes.

### üö® CRITICAL: Authorization is MANDATORY for Admin/Superadmin Routes

**ALL routes under `/api/admin/*` MUST call `requireAdminRole()`**  
**ALL routes under `/api/superadmin/*` MUST call `requireSuperadmin()`**

**Why:** UI protection is NOT enough - users can call APIs directly via tools like Postman, curl, or browser DevTools.

**Admin Route Pattern:**
```typescript
import { requireAdminRole } from '@/lib/auth/apiAuth';

export async function GET(request: NextRequest) {
  return withTenantContext(request, async (tenantId) => {
    // üîí MANDATORY: Check authorization FIRST
    await requireAdminRole(request);
    
    // Now safe to proceed with admin operations
    const data = await prisma.players.findMany({
      where: withTenantFilter(tenantId)
    });
    return NextResponse.json({ success: true, data });
  });
}
```

**Superadmin Route Pattern:**
```typescript
import { requireSuperadmin } from '@/lib/auth/apiAuth';

export async function GET(request: NextRequest) {
  try {
    // üîí MANDATORY: Check superadmin authorization FIRST
    await requireSuperadmin(request);
    
    // Now safe to access cross-tenant data
    const tenants = await supabaseAdmin.from('tenants').select('*');
    return NextResponse.json({ success: true, data: tenants });
  } catch (error) {
    return handleTenantError(error);
  }
}
```

**Authentication Helpers:**
- `requireAdminRole(request)` - Verifies admin OR superadmin access (use for `/api/admin/*`)
- `requireSuperadmin(request)` - Verifies ONLY superadmin access (use for `/api/superadmin/*`)
- `requirePlayerAccess(request)` - Verifies player access (use for `/api/player/*`)
- `requireAuth(request)` - Verifies authentication only (rarely needed)

**For public routes:** Use `withTenantContext(request, handler, { allowUnauthenticated: true })`

**‚ùå NEVER:**
- Rely on UI checks alone (users can bypass UI)
- Check `referer` header for authorization (easily spoofed)
- Assume middleware handles authorization (it only checks authentication)
- Skip auth checks because "it's an internal API" (still exploitable)

## React Query - Multi-Tenant Cache Isolation (MANDATORY)

### üö® CRITICAL: All Query Keys MUST Include tenant_id

**React Query caches data globally** - without tenant_id in keys, Tenant A's data can be served to Tenant B!

**Pattern:**
```typescript
export function usePlayers() {
  const { profile } = useAuth();
  return useQuery({
    queryKey: queryKeys.players(profile.tenantId),  // ‚úÖ MUST include tenantId
    queryFn: () => fetchPlayers(profile.tenantId),
    // NO enabled condition - causes race conditions
  });
}
```

**Key Rules:**
1. Include `tenantId` in query key (isolates cache per tenant)
2. Pass `tenantId` to fetchFn (graceful handling if null)
3. NO `enabled` condition (avoids permanent disable race)
4. Early return empty data if tenantId is null

**Exception:** `authProfile()` key does NOT need tenant_id (auth is global)

## API Response Headers - HTTP Cache (MANDATORY)

### üö® CRITICAL: Disable HTTP Caching for Tenant-Scoped Data

**NEVER use HTTP caching for tenant-scoped data** - browser cache persists stale data across tenant switches!

**Required Headers:**
```typescript
      headers: {
  'Cache-Control': 'no-store, must-revalidate',
  'Pragma': 'no-cache',
  'Vary': 'Cookie',
}
```

**Why:** HTTP cache persists across reloads, React Query handles in-memory caching correctly.  
**Exception:** Auth profile can use 1 min cache max.

## Multi-Tenant Security: RLS Strategy (MANDATORY - October 2025)

### üö® CRITICAL: RLS Architecture Decision

**Background:** Row-Level Security (RLS) + connection pooling causes intermittent 0-row query results. 
When middleware sets RLS context on Connection A, but query executes on Connection B without context, 
queries return 0 rows even with explicit `WHERE tenant_id = ...` filters.

**Solution:** Disable RLS on operational tables, enforce security via application-level `withTenantFilter()` helper.

### Database Security Model

**Tables with RLS ENABLED (Auth & Security Critical):**
- `auth.*` - Supabase auth system tables
- `tenants` - Superadmin-only access, requires RLS
- `admin_profiles` - Role/permission data, requires RLS

**Tables with RLS DISABLED (Operational - Use `withTenantFilter()`):**
- **Aggregated tables:** All tables starting with `aggregated_*` (read-only, populated by background jobs)
- **Core entities:** `players`, `matches`, `player_matches`, `seasons`
- **Match management:** `upcoming_matches`, `upcoming_match_players`, `match_player_pool`, `team_slots`
- **Configuration:** `app_config`, `balance_config`, `team_templates`
- **Player onboarding:** `player_join_requests`

### MANDATORY: Use `withTenantFilter()` Helper

**ALL queries MUST use `withTenantFilter()` for tenant isolation:**

```typescript
import { withTenantFilter } from '@/lib/tenantFilter';

// Simple: withTenantFilter(tenantId)
// With filters: withTenantFilter(tenantId, { is_retired: false })
// With OR/AND: withTenantFilter(tenantId, { OR: [...] })
// With composite keys: { ...withTenantFilter(tenantId), player_id }
```

**‚ùå NEVER use manual `tenant_id: tenantId` filtering** - use helper for type safety.

**Special cases:** Raw SQL and nested relations - see `docs/SPEC_multi_tenancy.md`

## App Router Flow
- Pages in `/app` should be minimal - just import and render components
- Business logic and UI should live in `/components`
- Example pattern:
```typescript
// /app/some-route/page.tsx
import { SomeComponent } from '@/components/feature';
export default function SomePage() {
  return <SomeComponent />;
}
```

## Component Template
```typescript
'use client';
import React from 'react';

interface ComponentProps {
  children: React.ReactNode;
  // other props
}

const ComponentName = ({ children }: ComponentProps) => {
  return (
    // component JSX
  );
};

export default ComponentName;
```

## Key Feature Directories
- `/components/dashboard/` - Dashboard widgets (PersonalBests, Milestones, MatchReport)
- `/components/records/` - All-time records (LeaderboardStats, Legends, Feats)  
- `/components/tables/` - Season standings (CurrentHalfSeason, OverallSeasonPerformance)
- `/components/ui-kit/` - Reusable UI components

### Canonical Player Data Types

To ensure consistency and type safety, all player-related data across the application must conform to the canonical types defined in `src/types/player.types.ts`.

-   **Primary Type:** `PlayerProfile` is the base interface for any player.
-   **Contextual Types:** Use extended types like `PlayerInPool` or `PlayerWithStats` for specific use cases (e.g., match management, statistics).
-   **API Boundary:** The API layer is responsible for transforming raw database results (snake_case) into these camelCase canonical types using the helpers in `src/lib/transform/player.transform.ts`. Frontend components should expect to receive data in this clean format.
-   **Deprecation:** Avoid using or creating any local, one-off player types (e.g., `MatchPlayer`, `PlayerWithNameAndId`). Always import from the canonical types file.
-   **ID Convention:** The canonical frontend type `PlayerProfile` uses `id: string` for consistency with component keys and other browser APIs. The database uses `player_id: number`. The transformation helpers in `src/lib/transform/player.transform.ts` are responsible for converting the numeric ID from the database to a string. Conversely, API routes must parse string IDs from the frontend back into numbers before performing database operations.

---

## Marketing Pages - Analytics & Attribution

**ONLY track marketing pages** (`/`, `/pricing`), **NOT authenticated app** (`/admin/*`, `/player/*`).

- Use `<PlausibleScript />` on marketing pages (auto-detects pathname)
- Use `useAttribution()` hook to capture first-touch attribution
- Attribution stored in `tenants.settings` JSON field on signup

See `docs/SPEC_Marketing.md` for implementation details (if needed).

---

# General Code Generation Rules

## SQL File Handling

### Schema Migrations
- **NEVER** create migration .sql files
- **ALWAYS** provide migration SQL in markdown blocks for manual execution in Supabase SQL editor
- **NEVER** use tools to execute exploratory SQL queries

### Business Logic SQL Functions
- **DO** create SQL function files in `/sql/` when implementing features that require complex database logic
- Use service prefix naming: `rsvp_*.sql`, `stats_*.sql`, etc.
- These are deployed via `deploy_all.ps1` script
- Examples: aggregation functions, state machines, complex filtering

### When to Use SQL Functions vs Application Code

**Use SQL functions in `/sql/` for:**
- Multi-table aggregations
- Performance-critical bulk operations  
- Complex business logic better expressed in SQL
- Logic that matches existing patterns (see `/sql/update_aggregated_*.sql`)

**Use application code for:**
- Simple CRUD operations
- Token generation/validation
- Rate limiting
- Session management
- API orchestration

## Modal & Dialog Standards

**MANDATORY:** All modals must follow standardized patterns for consistency. See `docs/SPEC_Modals.md` for complete specification.

### When to Use Which Pattern

**Simple Confirmations (90% of cases):**
- Use: `SoftUIConfirmationModal` (SweetAlert2 wrapper)
- For: Delete confirmations, save confirmations, logout, alerts, success messages
- Never use: Legacy ConfirmationDialog, ConfirmationModal, ConfirmDialog (deleted)

**Complex Forms:**
- Use: Mobile-safe custom modal pattern (see template in SPEC_Modals.md Template B)
- For: Add/edit forms, multi-step flows, custom layouts
- Must: Test with mobile keyboard

### Design Standards (MANDATORY)

**Icons:** SVG only (no emojis in UI), gradient backgrounds (see SPEC_Modals.md)  
**Buttons:** Context-dependent order - safe action on LEFT for destructive (see spec)  
**Mobile:** Form modals MUST use keyboard-safe pattern (see SPEC_Modals.md Template B)  
**Z-Index:** All modals use `z-50` (standard)

### Modal Creation Checklist

When creating a new modal:
1. [ ] Choose pattern: SoftUIConfirmationModal OR custom form
2. [ ] Use SVG icons (never emojis)
3. [ ] Apply gradient button styling
4. [ ] Use context-appropriate button order (constructive vs destructive)
5. [ ] Test on mobile (with keyboard if has inputs)
6. [ ] Add `role="dialog"` + `aria-modal="true"`
7. [ ] Add entry to `docs/SPEC_Modals.md` inventory table

## Mobile API Pattern (MANDATORY for New Code)

**For mobile app compatibility, always use `apiFetch()` helper:**

```typescript
import { apiFetch } from '@/lib/apiConfig';

// ‚úÖ CORRECT: Works in web, iOS, Android (dev & prod)
const response = await apiFetch('/players');
const response = await apiFetch('/admin/matches', { method: 'POST', body: JSON.stringify(data) });

// ‚ùå WRONG: Only works in web
const response = await fetch('/api/players');
```

**Why:** `apiFetch()` automatically routes to correct API endpoint:
- Web: `/api/*` (relative)
- Mobile dev: `http://localhost:3000/api/*` (live reload)
- Mobile prod: `https://app.caposport.com/api/*` (remote API)

**Migration Status:** ‚úÖ 218 uses across 62 files (existing code migrated)

**See:** `docs/MOBILE_SPEC.md` for architecture details

## Documentation Standards

**ALL documentation MUST live in `/docs` folder with standard prefixes:**

### Doc Naming Conventions

**Use standard prefixes:**
- `SPEC_[feature].md` - Technical specifications (e.g., `SPEC_auth.md`, `SPEC_multi_tenancy.md`)
- `MOBILE_[topic].md` - Mobile platform docs (e.g., `MOBILE_SPEC.md`, `MOBILE_USER_GUIDE.md`)
- `TESTFLIGHT_[topic].md` - TestFlight submission guides
- `PLAN_[feature].md` - Implementation plans
- `ARCHIVE_[name].md` - Deprecated content (moved from specs)
- `TEMP_[feature]_[date].md` - Temporary exploration docs (DELETE after feature complete)

**Subdirectories OK for related sets:**
- `ios/` - iOS-specific guides
- `mobile/` - Cross-platform mobile
- Keep sets small (< 10 files per directory)

### For Cursor: Temp Doc Cleanup (MANDATORY)

**During feature work, you may create exploration docs:**
1. Create as `TEMP_[feature]_[date].md` in `/docs`
2. Use for: breakdowns, spike notes, current status tracking
3. **After feature complete (MANDATORY):**
   - Extract valuable insights
   - Merge into relevant `SPEC_*.md`
   - **DELETE the temp file** (don't let them accumulate)

**Why:** Cursor creates MANY temp docs during complex features - discipline prevents doc sprawl

### Spec Maintenance Standards

**Goal:** Keep specs focused and efficient (target < 500 lines if possible)

**Standard spec structure:**
```markdown
# [Feature] Specification

**Last Updated:** [Date]
**Status:** Current / In Development / Deprecated

## Overview
[One paragraph - what this system does]

## Current Design
[How it works NOW - this is what Cursor reads most]

## Key Decisions & Rationale
- 2025-10: Why we chose X over Y
- 2025-09: Major architecture refactor

## Implementation Notes
[Gotchas, edge cases, important patterns]

---
## Archive
[Anything deprecated - OR move to ARCHIVE_*.md if huge]
```

**When to split a spec:**
Only if BOTH conditions met:
1. File exceeds 1000 lines
2. Has clearly separable concerns

**Don't overdo it:** Only split when genuinely needed for clarity/token efficiency

### Token Efficiency for Cursor Context

**When including specs:**
- Include ONLY the sections you need (not entire file)
- Use line ranges if possible: `@SPEC_auth.md:1-400`
- Archive sections (below `---`) are low priority - exclude unless investigating history
- Use `/docs/README.md` doc map to find the right spec quickly

**Why:** Large specs eat context windows - focused inclusion saves tokens

### Doc Map (Navigation Hub)

**Reference:** `/docs/README.md` - Complete inventory of all documentation
- Lists all specs with line counts and purposes
- "When to include" guidance for each spec
- Quick reference for finding the right doc
- **Keep this updated** when adding/removing docs

**NEVER create documentation in root directory** (exception: `README.md` only)

## Marketing Pages - Mobile Safe Area (MANDATORY)

**All marketing pages MUST respect iOS notch/Android status bar.**

### Pattern for New Marketing Pages

**Navigation:**
```tsx
<MarketingNav onGetApp={() => {}} />
// Already has pt-safe class built-in ‚úÖ
```

**Hero section:**
```tsx
<section className="min-h-screen pt-safe ...">
  {/* Hero content */}
</section>
```

**Content pages (privacy, terms, etc.):**
```tsx
<div style={{ paddingTop: 'calc(var(--safe-top, 0px) + 80px)' }} className="...">
  {/* Page content */}
</div>
```

**CSS Classes Available:**
- `.pt-safe` - Auto-adjusts for iOS notch, Android status bar, Web (none)
- Works across ALL platforms automatically!

**See:** `docs/SPEC_Marketing.md` for complete guide

## File Creation
- Only create new files when explicitly requested by the user.
- Prefer editing existing files over creating new ones.
- Clean up any temporary or test files created during development.

## Database Operations
- Provide all SQL queries as copyable code blocks.
- The user will execute the query and provide the results.
- Use the provided results for subsequent analysis and recommendations.
- **DO NOT** attempt to run database migrations (e.g., `prisma migrate`). The user will handle this.
